 # КТ: ДЗ4 -- TH, lens & benchmarks

Последнее задание курса помогает разобраться в более сложных концепциях языка программирования Haskell и существующих подходах в реализации концептуально-сложных, но полезных на практике библиотек.

## TemplateHaskell

Этот блок заданий нацелен на появление базового понимания `TemplateHaskell` и принципов его работы.

### Задание 1: Кортежи как списки

#### Основное задание

Реализуйте макрос `chooseByIndices`, который принимает список индексов, кортеж и возвращает новый кортеж, сформированный из элементов исходного кортежа, выбранных по переданным индексам. 

Пример работы:

```haskell=
ghci> $(chooseByIndices 4 [2, 0])          ("hello", 10, [4,3], 2)
([4, 3], "hello")
ghci> $(chooseByIndices 4 [1, 1, 3, 1, 1]) ("hello", 10, [4,3], 2)
(10, 10, 2, 10, 10)
```

#### Усложнённое задание

Придумайте, что можно сделать, чтобы не передавать длину кортежа аргументом функции `chooseByIndices`.

### Задание 2: Text Show

При помощи TemplateHaskell реализуйте макрос, который генерирует для заданного типа данных (очень простого, без переменных типа) инстанс некоторого класса типов, который как `Show`, только содержащий функцию конвертации типа данных не в `String`, а в `Text`.

## lens

Данный блок заданий посвящён линзам. В начале блока предлагается реализовать базовые операции по работе с линзами, чтобы лучше понимать, как устроена библиотека. А затем идут задания на использование линз, чтобы научиться пользоваться этим мощным инструментом.

### Задание 1: Базовые линзы

В этом задании запрещается использовать библиотеки с линзами.

#### Основное задание

Настоящие линзы имеют следующий тип:

```haskell=
type Lens s t a b = forall f . Functor f => (a -> f b) -> s -> f t
```

Но для простоты мы будем использовать линзы Ван Лаарховена (или же «простые линзы»):

```haskell=
type Lens' s a  = Lens s s a a
```

Реализуйте следующие базовые примитивы по работе с линзами:

```haskell
set  :: Lens' s a -> a -> s -> s         -- set    value (setter)
view :: Lens' s a -> s -> a              -- lookup value (getter)
over :: Lens' s a -> (a -> a) -> s -> s  -- change value (modifier)
```

**_Подсказка_:** используйте функторы `Const` и `Identity` для этого задания.

Можно использовать операторные формы этих функций:

```haskell
(.~) :: Lens' s a -> a -> s -> s
(^.) :: s -> Lens' s a -> a
(%~) :: Lens' s a -> (a -> a) -> s -> s
```

После этого реализуйте простейшие линзы для пары (!!! реализуйте эти функции вручную, запрещается использовать `lens` из усложнённой версии !!!):

```haskell=
-- _1 :: Functor f => (a -> f b) -> (a, x) -> f (b, x)
_1 :: Lens (a, x) (b, x) a b
_1 = _

-- _2 :: Functor f => (a -> f b) -> (x, a) -> f (x, b)
_2 :: Lens (x, a) (x, b) a b
_2 = _
```

Напишите юнит-тесты, которые проверяют, что ваши линзы `_1` и `_2` работают как ожидается вместе с функциями `set`, `view`, `over`.

#### Усложнённое задание

Линза представляет собой по сути пару из геттера и сеттера. Следовательно, прежде чем использовать линзу, необходимо научиться создавать её. Для этого реализуйте следующую функцию:

```haskell
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
lens get set = _
```

**Подсказка:** Если реализовать функцию выше тяжело, то попробуйте для начала реализовать более простую версию.

```haskell=
lens :: (s -> a) -> (s -> a -> s) -> Lens' s a
           │              │
           │              └─ setter
           │
           └── getter
```

После этого реализуйте линзы, которые сложней, чем `_1` и `_2`:

```haskell
-- Объединить две линзы в одну, которая работает с Either.
choosing :: Lens s1 t1 a b 
         -> Lens s2 t2 a b
         -> Lens (Either s1 s2) (Either t1 t2) a b
choosing l1 l2 = _

-- Изменить цель линзы и вернуть новый результат. Постарайтесь
-- реализовать без анонимных функций и определений своих функций
(<%~) :: Lens s t a b -> (a -> b) -> s -> (b, t)
(<%~) l f s = _

-- Изменить цель линзы, но вернуть старый результат.
(<<%~) :: Lens s t a b -> (a -> b) -> s -> (a, t)
(<<%~) l f s = _
```

### Задание 2: FileSystem lenses

> Начиная с этого задания разрешается использовать любую библиотеку с линзами.

Задан тип данных, которым можно представить простое дерево файловой системы:

```haskell
data FS 
    = Dir 
          { name     :: FilePath  -- название папки, не полный путь
          , contents :: [FS]
          }
    | File
          { name     :: FilePath  -- название файла, не полный путь
          }
```
Создайте функцию, которая «сканирует» заданную директорию и создаёт объект типа `FS` наподобие функции [`getDirectory'`](https://hackage.haskell.org/package/filesystem-trees-0.1.0.6/docs/System-File-Tree.html#v:getDirectory-39-).

После этого создайте базовые производные линзы и `Affine Traversals` для вашего типа данных.

### Практика на линзы

> Блок практики не оценивается баллами. Он лишь предоставляет набор команд, которые полезно научиться реализовывать в одну строку при помощи линз, прежде чем приступать к дальнейшим заданиям. Все команды в списке очень простые, но если Вы не можете выполнить и их, значит, Вы не до конца разобрались с линзами, и выполнять дальнейшие задания ещё рано.

1. Список поддеревьев папки для `Dir`, иначе пустой список.
2. `Maybe` с именем директории, если `Dir`, или `Nothing` иначе.
3. Имя файла, если `File`, или пустую строку иначе.
4. Изменить имя корня дерева на `/`.
5. Добавить произвольный суффикс к имени корня дерева.
6. Получить имя самой первой папки в списке поддиректорий (`Nothing`, если такой нет).
7. Получить список имён только `File` из `Dir` (нерекурсивно).

### Задание 3: Обходы FS

Реализуйте следующие `Lens` или `Traversal`:

1. `cd`: перейти в поддиректорию с указанным именем.
2. `ls`: получить список имён содержимого директории.
3. `file`: получить имя конкретного `File`, если он существует.

В итоге должна быть возможность делать нечто похожее:

```haskell
myDir ^?  cd "A" . cd "B" . file "C"  -- Just "C" при существовании myDir/A/B/C
myDir ^.. cd "A" . cd "B" . ls        -- получить содержимое myDir/A/B/
```

### Задание 4: Изменения структуры FS

#### Базовая версия

Реализуйте следующие функции, используя линзы:

1. Изменить в директории расширения всех файлов на другое (нерекурсивно).
2. Получить имена всех файлов и директорий рекурсивно.
3. Удалить выбранную поддиректорию, только если она пустая.

#### Усложнённое задание

4. Получить полный путь к файлу с названием файла относительно стартового узла `FS`.

Интерфейс должен быть следующим:

```haskell=
ghci> myDir ^? move "A" . move "B" . getPath  -- myDir is labeled by 'root'
Just "root/A/B/"
```

Разумеется, что все действия происходят над вашей структурой данных, а в вашей файловой системе ничего не меняется :)

### Задание 5: Консольный обход файловой системы

Воспользуйтесь функциями из предыдущих заданий для написания следующей функции (в комбинации с трансформерами `ReaderT` и `StateT`). Желательно придерживаться `MTL+Lens` паттерна программирования, при реализации следующей функции.

Функция запускается в папке с некоторым корнем, поддерживает команды перехода в папку и подняться наверх, и трекает число директорий и файлов, встреченных от корня до текущего пути. Печатайте на каждом шаге стартовый корень и текущую папку.

Пример файловой системы:

```
└─ path/to/smth
   ├─ A
   └─ B
      └─ Y.hs
   └─ X.hs 
```

Пример работы программы:

```shell=
$ walker "path/to/smth"
You in "path/to/smth/"
Files from root  "path/to/smth/": 1
Directories from "path/to/smth/": 2
> cd B
You in "path/to/smth/B/"
Files from root  "path/to/smth/": 2
Directories from "path/to/smth/": 2
> up
You in "path/to/smth/"
Files from root  "path/to/smth": 1
Directories from "path/to/smth": 2
```

### Задание 6*: Изоморфизмы

> В этом задании снова необходимо обойтись без библиотеки линз

Дан следующий тип изоморфизма между типами `b` и `a`:

```haskell=
type Iso b a = forall p f. (Profunctor p, Functor f) => p a (f a) -> p b (f b)
```

1. Реализуйте функцию, которая создаёт изоморфизм:

```haskell=
iso :: (b -> a) -> (a -> b) -> Iso b a 
```

2. После этого напишите функцию, получающую обратный изоморфизм:

```haskell=
from :: Iso b a -> Iso a b
```

Для `from` используйте функции `lmap` и `rmap` из класса типов [`Profunctor`](https://www.stackage.org/haddock/lts-9.14/profunctors-5.2.1/Data-Profunctor.html#t:Profunctor). 

```haskell=
class Profunctor p where
    dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
    lmap  :: (a -> b)             -> p b c -> p a c
    rmap  ::             (b -> c) -> p a b -> p a c
```

Также используйте тип данных [`Tagged`](http://hackage.haskell.org/package/tagged-0.8.5/docs/Data-Tagged.html#t:Tagged):

```haskell=
newtype Tagged s b = Tagged { unTagged :: b }
```

3. После этого реализуйте изоморфизм между вашим типом данных `FS` и типом данныx `Tree` из модуля [`Data.Tree`](http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Tree.html).

Вы можете использовать изоморфизмы как обычные функции:

```haskell=
ghci> let f = iso Just (fromMaybe 0)
ghci> 1 ^. f
Just 1
ghci> Just 3 ^. from f
3
ghci> Nothing ^. from f
0
```

## benchmarks

В этом блоке необходимо выбрать из предложенных или придумать свою задачу для измерения скорости работы. Необходимо реализовать какой-нибудь алгоритм самостоятельно, сравить с существующим из стандартной библиотеки, а затем постараться улучшить свою реализацию, чтобы она стала быстрей по скорости. При этом необходимо продумать, как лучше тестировать производительность.

1. Стандартная сортировка, ваша mergeSort и ещё парочка каких-нибудь реализаций.
2. `nub` из стандартной библиотеки и парочка ваших реализаций.
3. Какая-нибудь функция из `ilist` и наивная реализация.
4. Какая-нибудь функция из пакета `loops` и своя наивная реализация (вроде `forM_ [1..n]`).

Так как не очень хорошо, если все выберут одно и то же задание, то вводится лимит в 5 человек, которые могут выбрать один пункт из списка выше. Для этого необходимо заранее (до дедлайна) написать, что Вы выбираете. Если этого не сделать, то задание зачтено не будет.