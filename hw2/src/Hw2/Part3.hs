module Hw2.Part3 where

newtype Parser s a = Parser { runParser :: [s] -> Maybe (a, [s]) }

-- В отличие от парсера из презентации он может работать не только со строкой,
-- но и с любым потоком данных. Реализуйте вручную инстансы Functor, Applicative,
-- Monad и Alternative для этого парсера.

{-
Задание 2: Базовые комбинаторы

Реализуйте следующие базовые комбинаторы:

    ok — парсер никогда не падает и не поглащает инпут.
    eof — проверяет, что парсер дошёл до конца потока данных (иначе падает).
    satisfy — парсер принимает предикат на элемент потока, и возвращает элемент, поглащая его из потока, если предикат на элемент равен True, иначе падает.
    element и stream — парсят один или несколько элементов потока (как char и string).

Задание 3: Простые парсеры

Используя существующие комбинаторы (реализовав по необходимости остальные) напишите следующие парсеры строковых потоков:

    Парсер правильных скобочных последовательностей (падает, если последовательность неправильная, и не падает, если правильная).
    Парсер целого числа, перед которым может быть знак + или -.

Задание 4: Непростой парсер

Написать парсер списка списков чисел, разделённых запятой. Все числа перечисленны через запятую. В начале каждого списка находится число — длина списка. Таким образом можно понять, где заканчивается каждый список. То есть список

[ [1, 10], [5, -7, 2] ]

в строковом виде может быть записан следующим образом:

"2, 1,+10  , 3,5,-7, 2"
-}
